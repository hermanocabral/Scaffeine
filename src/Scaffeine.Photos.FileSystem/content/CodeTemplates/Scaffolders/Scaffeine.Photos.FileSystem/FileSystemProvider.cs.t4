<#@ Template Language="C#" HostSpecific="True" Inherits="DynamicTransform" #>
<#@ Output Extension="cs" #>
namespace <#= Model.Namespace #>.Photos.FileSystem
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Configuration.Provider;
    using System.Drawing;
    using System.IO;
    using System.Linq;
    using System.Security.AccessControl;

    using <#= Model.Namespace #>.Photos.Helpers;
    using <#= Model.Namespace #>.Photos.Models;

    /// <summary>
    /// The file system provider.
    /// </summary>
    public class FileSystemProvider : PhotoProvider
    {
        /// <summary>
        /// The _file path.
        /// </summary>
        private string _filePath;

        /// <summary>
        /// The search pattern.
        /// </summary>
        private const string SearchPattern = ".bmp,.gif,.jpg,.jpeg,.png";

        /// <summary>
        /// The initialize.
        /// </summary>
        /// <param name="name">
        /// The name.
        /// </param>
        /// <param name="config">
        /// The config.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// </exception>
        /// <exception cref="ProviderException">
        /// </exception>
        public override void Initialize(string name, NameValueCollection config)
        {
            base.Initialize(name, config);

            if (config == null)
            {
                throw new ArgumentNullException("config");
            }

            this._filePath = config["imageFolder"];
            if (string.IsNullOrEmpty(this._filePath))
            {
                throw new ProviderException("Empty or missing 'imageFolder' value");
            }

            config.Remove("imageFolder");

            if (config.Count > 0)
            {
                var attr = config.GetKey(0);
                if (!string.IsNullOrWhiteSpace(attr))
                {
                    throw new ProviderException("Unrecognized attribute: " + attr);
                }
            }
        }

        #region Overrides of PhotoProvider

        /// <summary>
        /// The save photo resize.
        /// </summary>
        /// <param name="item">
        /// The item.
        /// </param>
        /// <param name="resizeName">
        /// The resize name.
        /// </param>
        /// <returns>
        /// The MvcApplication36.Photos.Models.Photo.
        /// </returns>
        public override Photo SavePhotoResize(PhotoRequest item, string resizeName)
        {
            // todo: if resizeName doesn't exist, then we need to throw an exception
            var photoResize = PhotoManager.PhotoResizes[resizeName];

            using (var stream = item.Stream)
            {
                string extension = GetExtension(item.MimeType);
                string name = string.Format("{0}{1}", DateTime.UtcNow.ToString("dd_MM_yyyy_hh_mm_ss_ffff"), extension);
                var photo = SaveImage(
                    stream, photoResize.Width, photoResize.Height, resizeName, name, item.MimeType ?? "image/jpeg");

                return photo;
            }
        }

        /// <summary>
        /// The save photo for all sizes.
        /// </summary>
        /// <param name="item">
        /// The item.
        /// </param>
        /// <param name="keepOriginalSize">
        /// The keep original size.
        /// </param>
        /// <returns>
        /// The System.Collections.Generic.IList`1[T -&gt; MvcApplication36.Photos.Models.Photo].
        /// </returns>
        public override IList<Photo> SavePhotoForAllSizes(PhotoRequest item, bool keepOriginalSize)
        {
            var photoResizes = PhotoManager.PhotoResizes;

            using (var stream = item.Stream)
            {
                string extension = GetExtension(item.MimeType);
                string name = string.Format("{0}{1}", DateTime.UtcNow.ToString("dd_MM_yyyy_hh_mm_ss_ffff"), extension);

                List<Photo> photos =
                    photoResizes.Select(
                        resize =>
                        SaveImage(
                            stream,
                            resize.Value.Width,
                            resize.Value.Height,
                            resize.Key,
                            name,
                            item.MimeType ?? "image/jpeg")).ToList();

                if (keepOriginalSize)
                {
                    using (Image image = Image.FromStream(stream))
                    {
                        var photo = SaveImage(
                            stream, image.Width, image.Height, null, name, item.MimeType ?? "image/jpeg");
                        photos.Add(photo);
                    }
                }

                return photos;
            }
        }

        /// <summary>
        /// The get photo resize.
        /// </summary>
        /// <param name="id">
        /// The id.
        /// </param>
        /// <param name="resizeName">
        /// The resize name.
        /// </param>
        /// <returns>
        /// The MvcApplication36.Photos.Models.Photo.
        /// </returns>
        public override Photo GetPhotoResize(string id, string resizeName)
        {
            var photo = GetPhoto(id, resizeName);

            return photo;
        }

        /// <summary>
        /// The get all photo resizes.
        /// </summary>
        /// <param name="id">
        /// The id.
        /// </param>
        /// <returns>
        /// The System.Collections.Generic.IDictionary`2[TKey -&gt; System.String, TValue -&gt; MvcApplication36.Photos.Models.Photo].
        /// </returns>
        public override IDictionary<string, Photo> GetAllPhotoResizes(string id)
        {
            var photoResizes = PhotoManager.PhotoResizes;
            var photos = new Dictionary<string, Photo>();

            foreach (var resize in photoResizes)
            {
                var photo = GetPhoto(id, resize.Key);

                if (photo != null)
                {
                    photos.Add(resize.Key, photo);
                }
            }

            var originalPhoto = GetPhoto(id, null);

            if (originalPhoto != null)
            {
                photos.Add("original", originalPhoto);
            }

            return photos;
        }

        /// <summary>
        /// The get photos by resize.
        /// </summary>
        /// <param name="resizeName">
        /// The resize name.
        /// </param>
        /// <param name="ids">
        /// The ids.
        /// </param>
        /// <returns>
        /// The System.Collections.Generic.IList`1[T -&gt; MvcApplication36.Photos.Models.Photo].
        /// </returns>
        public override IList<Photo> GetPhotosByResize(string resizeName, string[] ids)
        {
            string physicalPath = System.Web.HttpContext.Current.Server.MapPath(_filePath);

            if (!string.IsNullOrWhiteSpace(resizeName))
            {
                physicalPath = Path.Combine(physicalPath, resizeName);
            }

            string resizeFolder = resizeName != null ? string.Format("{0}/", resizeName) : string.Empty;

            // todo: @rsanjar: Add a comment here on what this code is doing.  I think the forula for getting an Id should be in it's own function
            var photos =
                GetFilesByExtensions(physicalPath, SearchPattern.Split(',')).Where(
                    c => ids.Contains(c.Name.Split('.')[0])).Select(
                        c =>
                        new Photo
                            {
                                Id = c.Name,
                                ResizeName = resizeName,
                                Url = string.Format("{0}/{1}{2}", _filePath.TrimEnd('/'), resizeFolder, c.Name)
                            }).ToList();

            return photos;
        }

        #endregion

        #region private methods

        /// <summary>
        /// The save image.
        /// </summary>
        /// <param name="stream">
        /// The stream.
        /// </param>
        /// <param name="width">
        /// The width.
        /// </param>
        /// <param name="height">
        /// The height.
        /// </param>
        /// <param name="resizeName">
        /// The resize name.
        /// </param>
        /// <param name="imageFileName">
        /// The image file name.
        /// </param>
        /// <param name="mimeType">
        /// The mime type.
        /// </param>
        /// <returns>
        /// The MvcApplication36.Photos.Models.Photo.
        /// </returns>
        private Photo SaveImage(
            Stream stream,
            int width,
            int height,
            string resizeName,
            string imageFileName,
            string mimeType = "image/jpeg")
        {
            string physicalPath = System.Web.HttpContext.Current.Server.MapPath(_filePath);

            if (!string.IsNullOrWhiteSpace(resizeName))
            {
                physicalPath = Path.Combine(physicalPath, resizeName);
            }

            // Create a directory for the specified resizeName if not exists
            if (!Directory.Exists(physicalPath))
            {
                Directory.CreateDirectory(physicalPath);
                GrantAccess(physicalPath);
            }

            string fileName = Path.Combine(physicalPath, imageFileName);

            using (var resizedImage = ImageHelper.ResizeImage(stream, width, height))
            {
                ImageHelper.SaveImage(fileName, resizedImage, 90, mimeType);
            }

            // todo: again, need to isolate the logic to get file path, shouldn't be part of this function
            string extension = GetExtension(mimeType);
            string resizeFolder = resizeName != null ? string.Format("{0}/", resizeName) : string.Empty;

            var photo = new Photo
                {
                    Id = imageFileName.Replace(extension, string.Empty).Trim('.'),
                    ResizeName = resizeName,
                    Url = string.Format("{0}/{1}{2}", _filePath.TrimEnd('/'), resizeFolder, imageFileName)
                };

            return photo;
        }

        /// <summary>
        /// The get photo.
        /// </summary>
        /// <param name="id">
        /// The id.
        /// </param>
        /// <param name="resizeName">
        /// The resize name.
        /// </param>
        /// <returns>
        /// The MvcApplication36.Photos.Models.Photo.
        /// </returns>
        private Photo GetPhoto(string id, string resizeName)
        {
            Photo photo = null;
            string physicalPath = System.Web.HttpContext.Current.Server.MapPath(_filePath);

            if (!string.IsNullOrWhiteSpace(resizeName))
            {
                physicalPath = Path.Combine(physicalPath, resizeName);
            }

            // todo: need to throw exception if file doesnt exist at all..
            var file = new FileInfo(Path.Combine(physicalPath, id));

            // if id doesn't contain extension then search by file name
            if (!file.Exists)
            {
                file = new DirectoryInfo(physicalPath).GetFiles().FirstOrDefault(c => c.Name.StartsWith(id));
            }

            if (file != null)
            {
                string resizeFolder = resizeName != null ? string.Format("{0}/", resizeName) : string.Empty;
                string virtualImagePath = string.Format("{0}/{1}{2}", _filePath.TrimEnd('/'), resizeFolder, file.Name);

                photo = new Photo { Id = file.Name.Split('.')[0], ResizeName = resizeName, Url = virtualImagePath };
            }

            return photo;
        }

        /// <summary>
        /// The grant access.
        /// </summary>
        /// <param name="fullPath">
        /// The full path.
        /// </param>
        private void GrantAccess(string fullPath)
        {
            var directoryInfo = new DirectoryInfo(fullPath);

            var directorySecurity = directoryInfo.GetAccessControl();
            directorySecurity.AddAccessRule(
                new FileSystemAccessRule(
                    "everyone",
                    FileSystemRights.FullControl,
                    InheritanceFlags.ObjectInherit | InheritanceFlags.ContainerInherit,
                    PropagationFlags.NoPropagateInherit,
                    AccessControlType.Allow));
            directoryInfo.SetAccessControl(directorySecurity);
        }

        /// <summary>
        /// The get files by extensions.
        /// </summary>
        /// <param name="path">
        /// The path.
        /// </param>
        /// <param name="extensions">
        /// The extensions.
        /// </param>
        /// <returns>
        /// The System.Collections.Generic.IEnumerable`1[T -&gt; System.IO.FileInfo].
        /// </returns>
        private IEnumerable<FileInfo> GetFilesByExtensions(string path, params string[] extensions)
        {
            var dirInfo = new DirectoryInfo(path);

            var allowedExtensions = new HashSet<string>(extensions, StringComparer.OrdinalIgnoreCase);

            var photos = dirInfo.GetFiles().Where(f => allowedExtensions.Contains(f.Extension));

            return photos;
        }

        /// <summary>
        /// The get extension.
        /// </summary>
        /// <param name="mimeType">
        /// The mime type.
        /// </param>
        /// <param name="defaultExtension">
        /// The default extension.
        /// </param>
        /// <returns>
        /// The System.String.
        /// </returns>
        private string GetExtension(string mimeType, string defaultExtension = ".jpeg")
        {
            // todo: need to isolate the logic here for parsing the value
            string extension = mimeType.Split('/').Length > 1 ? mimeType.Split('/')[1] : defaultExtension;
            extension = string.Format(".{0}", extension.Trim('.'));

            if (!SearchPattern.Split(',').Contains(extension))
            {
                extension = ".jpeg";
            }

            return extension;
        }

        #endregion
    }
}